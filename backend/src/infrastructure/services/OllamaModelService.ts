import type { ITenderAnalyzer } from '../../domain/interfaces/ITenderAnalyzer.js';
import type { TenderAnalysis } from '../../domain/entities/TenderAnalysis.js';
import { AppError } from '../../domain/errors/AppError.js';
import ollama from 'ollama';

export class OllamaModelService implements ITenderAnalyzer {
  private readonly MODEL = "llama3"; 

  // Structured output schema hint for the model
  private readonly JSON_SCHEMA_HINT = `
    Respond strictly with valid JSON. Do not include markdown formatting or explanations outside the JSON.
    Format:
    {
      "title": "string",
      "summary": "string",
      "requirements": [
        { 
          "id": "string",
          "text": "string",
          "type": "MANDATORY" | "DESIRABLE"
        }
      ]
    }
  `;

  async analyze(text: string): Promise<TenderAnalysis> {
    const prompt = `
      Task: Extract Technical Requirements from this Public Tender Document.
      
      DOCUMENT EXCERPT:
      "${text.slice(0, 6000)}"

      INSTRUCTION:
      Identify specific technical constraints, solvency requirements, or deliverables.
      Ignore administrative boilerplate.
      
      Respond strictly with this JSON format:
      ${this.JSON_SCHEMA_HINT}
    `;

    try {
      console.log(`[Ollama] Generating Tender Analysis (Step 1)...`);
      const response = await ollama.chat({
        model: this.MODEL,
        messages: [{ role: 'user', content: prompt }],
        format: 'json',
        stream: false,
      });

      const content = response.message.content;
      console.log(`[Ollama] Analysis received (${content.length} chars). Parsing...`);
      let result;
      try {
        result = JSON.parse(content);
      } catch (e) {
        console.error("JSON Parse Error:", e);
        throw new Error("Invalid JSON from LLM");
      }
      
      // Map to Domain Entity
      // Note: TenderAnalysis usually requires 'id' but that is generated by Repository/Controller usually. 
      // Checking definition...
      return {
          id: 'temp-id', // Use 'id' instead of 'tenderId' if that's the entity key
          title: result.title || "Untitled Tender",
          summary: result.summary || "No summary provided",
          requirements: (result.requirements || []).map((r: any, idx: number) => ({
              id: r.id || `REQ-${idx + 1}`,
              text: r.text || "Unknown Requirement",
              type: r.type || 'MANDATORY'
          })),
          risks: [],
          score: 0,
          createdAt: new Date(),
          status: 'ANALYZED'
      } as TenderAnalysis;

    } catch (error: any) {
        console.error('[Ollama] Analysis Error:', error);
        throw AppError.internal("Failed to analyze tender with Ollama: " + error.message);
    }
  }

  async compareProposal(
    requirementText: string,
    proposalText: string,
    legalContext: string[] = []
  ): Promise<{ status: 'COMPLIANT' | 'NON_COMPLIANT' | 'PARTIAL'; reasoning: string; score: number; sourceQuote: string }> {
    
    const contextPrompt = legalContext.length > 0 
        ? `\nLEGAL CONTEXT (from LCSP/Laws):\n${legalContext.join('\n')}\nINSTRUCTION: Ensure the evaluation considers these legal constraints.` 
        : '';

    const prompt = `
      Current Task: Public Tender Compliance Audit.
      
      REQUIREMENT:
      "${requirementText}"

      PROPOSAL EXCERPT:
      "${proposalText.slice(0, 4000)}"

      ${contextPrompt}

      Compare the Proposal against the Requirement.
      ${this.JSON_SCHEMA_HINT}
    `;

    try {
      console.log(`[Ollama] Sending request to model: ${this.MODEL}...`);
      const response = await ollama.chat({
        model: this.MODEL,
        messages: [{ role: 'user', content: prompt }],
        format: 'json', // Force JSON mode in Ollama
        stream: false,
      });

      const content = response.message.content;
      console.log(`[Ollama] Response received (${content.length} chars).`);

      try {
          const result = JSON.parse(content);
          // Normalize output keys if model hallucinates capitalization
          return {
              status: result.status || result.Status || 'PARTIAL',
              reasoning: result.reasoning || result.Reasoning || 'Analysis failed to parse.',
              score: Number(result.score || result.Score || 0),
              sourceQuote: result.sourceQuote || result.SourceQuote || 'N/A'
          };
      } catch (parseError) {
          console.error("Failed to parse Ollama JSON:", content);
          throw AppError.internal("Ollama response was not valid JSON");
      }

    } catch (error: any) {
      console.error('[Ollama] Connection Error:', error);
      
      // Check if model needs pulling
      if (error?.message?.includes('pull access denied') || error?.status === 404) {
          throw AppError.badRequest(`Model '${this.MODEL}' not found. Run 'ollama pull ${this.MODEL}' in terminal.`);
      }

      // Fallback
      return {
          status: 'PARTIAL',
          reasoning: `Ollama Error: ${error.message}. Is Ollama running?`,
          score: 0,
          sourceQuote: 'System Error'
      };
    }
  }
}
